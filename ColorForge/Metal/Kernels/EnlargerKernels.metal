//
//  EnlargerKernels.metal
//  ColorForge
//
//  Created by admin on 23/05/2025.
//

#include <metal_stdlib>
#include <CoreImage/CoreImage.h>
#include "GlobalHelperFunctions.metal"

using namespace metal;

extern "C" {
	
	
	// MARK: - Boiler plate kernels
	
	/*
	 
	 float4 name(coreimage::sample_t s) {
		 float3 rgb = float3(s.r, s.g, s.b);
		 
		 
		 return float4(rgb, s.a);
	 }
	 
	 */
	
	
	// MARK: - Constants
	
	// No Split Tone
	constant float outputMap[32][3] = {
		{0.9137254902, 0.9137254902, 0.9137160433},
		{0.9137254902, 0.9137251008, 0.9132164287},
		{0.9137254902, 0.9136863092, 0.9065719407},
		{0.9137254902, 0.9127539646, 0.8690264908},
		{0.9137248995, 0.9037319907, 0.7612881037},
		{0.9136952338, 0.8633435192, 0.5822429465},
		{0.9131453779, 0.7671307204, 0.3835657605},
		{0.9085740807, 0.6215398499, 0.2221173575},
		{0.8890990171, 0.4559826974, 0.1267670173},
		{0.8402518349, 0.3020768924, 0.0835366824},
		{0.7569793280, 0.1854755668, 0.0684758157},
		{0.6440434789, 0.1139494993, 0.0640181297},
		{0.5138248164, 0.0799506500, 0.0629191631},
		{0.3953151219, 0.0676461981, 0.0627563642},
		{0.2981979460, 0.0638404663, 0.0627453858},
		{0.2110902388, 0.0628931690, 0.0627450980},
		{0.1411527197, 0.0627545404, 0.0627450980},
		{0.1002665023, 0.0627453351, 0.0627450980},
		{0.0810581272, 0.0627450980, 0.0627450980},
		{0.0718593436, 0.0627450980, 0.0627450980},
		{0.0671789120, 0.0627450980, 0.0627450980},
		{0.0646138308, 0.0627450980, 0.0627450980},
		{0.0632616679, 0.0627450980, 0.0627450980},
		{0.0628179136, 0.0627450980, 0.0627450980},
		{0.0627495474, 0.0627450980, 0.0627450980},
		{0.0627451996, 0.0627450980, 0.0627450980},
		{0.0627450980, 0.0627450980, 0.0627450980},
		{0.0627450980, 0.0627450980, 0.0627450980},
		{0.0627450980, 0.0627450980, 0.0627450980},
		{0.0627450980, 0.0627450980, 0.0627450980},
		{0.0627450980, 0.0627450980, 0.0627450980},
		{0.0627450980, 0.0627450980, 0.0627450980}
	};
	
	
	constant float ilfordRC_v1[32][3] = {
		{0.9770000000, 0.9770000000, 0.9770000000},
		{0.9770000000, 0.9770000000, 0.9770000000},
		{0.9770000000, 0.9770000000, 0.9770000000},
		{0.9770000000, 0.9770000000, 0.9770000000},
		{0.9652478000, 0.9652478000, 0.9652478000},
		{0.9239280000, 0.9239280000, 0.9239280000},
		{0.8425662000, 0.8425662000, 0.8425662000},
		{0.7121402000, 0.7121402000, 0.7121402000},
		{0.5364117000, 0.5364117000, 0.5364117000},
		{0.3513402000, 0.3513402000, 0.3513402000},
		{0.2061814000, 0.2061814000, 0.2061814000},
		{0.1168543000, 0.1168543000, 0.1168543000},
		{0.0606237000, 0.0606237000, 0.0606237000},
		{0.0262143000, 0.0262143000, 0.0262143000},
		{0.0113369000, 0.0113369000, 0.0113369000},
		{0.0097370000, 0.0097370000, 0.0097370000},
		{0.0096769000, 0.0096769000, 0.0096769000},
		{0.0096677000, 0.0096677000, 0.0096677000},
		{0.0096706000, 0.0096706000, 0.0096706000},
		{0.0096809000, 0.0096809000, 0.0096809000},
		{0.0096946000, 0.0096946000, 0.0096946000},
		{0.0097113000, 0.0097113000, 0.0097113000},
		{0.0097292000, 0.0097292000, 0.0097292000},
		{0.0097472000, 0.0097472000, 0.0097472000},
		{0.0097652000, 0.0097652000, 0.0097652000},
		{0.0097814000, 0.0097814000, 0.0097814000},
		{0.0097965000, 0.0097965000, 0.0097965000},
		{0.0098097000, 0.0098097000, 0.0098097000},
		{0.0098191000, 0.0098191000, 0.0098191000},
		{0.0098254000, 0.0098254000, 0.0098254000},
		{0.0098278000, 0.0098278000, 0.0098278000},
		{0.0098244000, 0.0098244000, 0.0098244000}
	};
	
	constant float ilfordRC_v3[32][3] = {
		{0.918895, 0.918895, 0.918895},
		{0.915095, 0.915095, 0.915095},
		{0.905635, 0.905635, 0.905635},
		{0.884882, 0.884882, 0.884882},
		{0.848566, 0.848566, 0.848566},
		{0.795465, 0.795465, 0.795465},
		{0.725192, 0.725192, 0.725192},
		{0.642045, 0.642045, 0.642045},
		{0.553711, 0.553711, 0.553711},
		{0.467818, 0.467818, 0.467818},
		{0.391413, 0.391413, 0.391413},
		{0.326133, 0.326133, 0.326133},
		{0.270924, 0.270924, 0.270924},
		{0.224676, 0.224676, 0.224676},
		{0.186307, 0.186307, 0.186307},
		{0.154707, 0.154707, 0.154707},
		{0.128851, 0.128851, 0.128851},
		{0.108126, 0.108126, 0.108126},
		{0.091785, 0.091785, 0.091785},
		{0.079218, 0.079218, 0.079218},
		{0.069785, 0.069785, 0.069785},
		{0.062822, 0.062822, 0.062822},
		{0.057717, 0.057717, 0.057717},
		{0.053833, 0.053833, 0.053833},
		{0.050836, 0.050836, 0.050836},
		{0.048645, 0.048645, 0.048645},
		{0.047092, 0.047092, 0.047092},
		{0.046093, 0.046093, 0.046093},
		{0.045538, 0.045538, 0.045538},
		{0.045455, 0.045455, 0.045455},
		{0.045455, 0.045455, 0.045455},
		{0.045455, 0.045455, 0.045455}
	};
	
	constant float printCurveJune25[32][3] = {
		{0.9340000000, 0.9330000000, 0.9350000000},
		{0.9340440000, 0.9331380000, 0.9351550000},
		{0.9340660000, 0.9330980000, 0.9346040000},
		{0.9340200000, 0.9322710000, 0.9321880000},
		{0.9338660000, 0.9292190000, 0.9242440000},
		{0.9335530000, 0.9125310000, 0.8586910000},
		{0.9330050000, 0.8443930000, 0.6526640000},
		{0.9320810000, 0.6779610000, 0.4886180000},
		{0.9304230000, 0.5158330000, 0.2984270000},
		{0.9252970000, 0.3617560000, 0.1629510000},
		{0.8903520000, 0.2302370000, 0.1027090000},
		{0.8297990000, 0.1443920000, 0.0583130000},
		{0.7453490000, 0.0959840000, 0.0298020000},
		{0.6171390000, 0.0611130000, 0.0261160000},
		{0.4814960000, 0.0451250000, 0.0245200000},
		{0.3496810000, 0.0421440000, 0.0235290000},
		{0.2511710000, 0.0406550000, 0.0228620000},
		{0.1751360000, 0.0396070000, 0.0224070000},
		{0.1183120000, 0.0387990000, 0.0221020000},
		{0.0860010000, 0.0381480000, 0.0219110000},
		{0.0580780000, 0.0376110000, 0.0218100000},
		{0.0445810000, 0.0371620000, 0.0217810000},
		{0.0364700000, 0.0367840000, 0.0218130000},
		{0.0311560000, 0.0364640000, 0.0218940000},
		{0.0276070000, 0.0361940000, 0.0220170000},
		{0.0252780000, 0.0359680000, 0.0221750000},
		{0.0238390000, 0.0357800000, 0.0223630000},
		{0.0230610000, 0.0356270000, 0.0225740000},
		{0.0227750000, 0.0355050000, 0.0228030000},
		{0.0228420000, 0.0354130000, 0.0230430000},
		{0.0231360000, 0.0353480000, 0.0232890000},
		{0.0235290000, 0.0353090000, 0.0235290000}
	};
	
	
	// MARK: - Enlarger curve output map constants
	
	constant float minus1ev[32][3] = {
		{0.0000000000, 0.0000000000, 0.0000000000},
		{0.0261233548, 0.0278245484, 0.0331540645},
		{0.0522467097, 0.0556500323, 0.0663081290},
		{0.0783701613, 0.0834746452, 0.0994621935},
		{0.1032185484, 0.1097247097, 0.1306172903},
		{0.1174234839, 0.1228333226, 0.1452671935},
		{0.1223863871, 0.1245313871, 0.1464830000},
		{0.1273486774, 0.1262294516, 0.1482750000},
		{0.1323117742, 0.1279272581, 0.1500670000},
		{0.1372745806, 0.1296245806, 0.1518590000},
		{0.1422369677, 0.1313226452, 0.1536510000},
		{0.1472000645, 0.1347729032, 0.1554430000},
		{0.1531421290, 0.1438587097, 0.1625935806},
		{0.1620074194, 0.1567619355, 0.1798858065},
		{0.1727600000, 0.1711925161, 0.1989389032},
		{0.1883531290, 0.1911026452, 0.2178527419},
		{0.2105998387, 0.2149973548, 0.2366212581},
		{0.2340129677, 0.2388920645, 0.2553897742},
		{0.2574256129, 0.2627873548, 0.2741582903},
		{0.2808388710, 0.2866824839, 0.2929261935},
		{0.3042519032, 0.3105771935, 0.3116943226},
		{0.3276652258, 0.3351506774, 0.3305800323},
		{0.3518801290, 0.3673943548, 0.3501488065},
		{0.3997916129, 0.4273554839, 0.3853545161},
		{0.4705038710, 0.4892868387, 0.4405890968},
		{0.5457730323, 0.5498811935, 0.5021069032},
		{0.6132640000, 0.5740248710, 0.5564834194},
		{0.6235290000, 0.5764710000, 0.5647060000},
		{0.6235290000, 0.5764710000, 0.5647060000},
		{0.6235290000, 0.5764710000, 0.5647060000},
		{0.6235290000, 0.5764710000, 0.5647060000},
		{0.6235290000, 0.5764710000, 0.5647060000}
	};
	
	constant float plus1ev[32][3] = {
		{0.0000000000, 0.0000000000, 0.0000000000},
		{0.0802043548, 0.0828934194, 0.0465950968},
		{0.1604077742, 0.1657867742, 0.0931901935},
		{0.2406121613, 0.2486792581, 0.1397852903},
		{0.3189130645, 0.3295091935, 0.1896240000},
		{0.3813361935, 0.3931266774, 0.2740473548},
		{0.4299712258, 0.4417966129, 0.4043947097},
		{0.4786068710, 0.4904665484, 0.4557689355},
		{0.5272417097, 0.5391367419, 0.5071426129},
		{0.5758768387, 0.5878074194, 0.5585167742},
		{0.6245123871, 0.6364773548, 0.6098905161},
		{0.6731472258, 0.6811684839, 0.6612646129},
		{0.7171941935, 0.7130626774, 0.7057968710},
		{0.7475438387, 0.7362884839, 0.7373814516},
		{0.7690494516, 0.7579467419, 0.7661766774},
		{0.7859127097, 0.7739823226, 0.7863353871},
		{0.7963968387, 0.7859301935, 0.7974791290},
		{0.8057619677, 0.7978780323, 0.8086228387},
		{0.8151271935, 0.8098253871, 0.8197666452},
		{0.8244922581, 0.8217727419, 0.8309102903},
		{0.8338575484, 0.8337200968, 0.8420541613},
		{0.8432232258, 0.8425696129, 0.8522615484},
		{0.8522631613, 0.8476205806, 0.8570040645},
		{0.8520781935, 0.8504197419, 0.8597119032},
		{0.8551760000, 0.8557549677, 0.8627150000},
		{0.8605520000, 0.8573865484, 0.8657870000},
		{0.8559758710, 0.8586015806, 0.8666179677},
		{0.8549020000, 0.8588240000, 0.8666670000},
		{0.8549020000, 0.8588240000, 0.8666670000},
		{0.8549020000, 0.8588240000, 0.8666670000},
		{0.8549020000, 0.8588240000, 0.8666670000},
		{0.8549020000, 0.8588240000, 0.8666670000}
	};
	
	
	constant float minus20m[32][3] = {
		{0.0000000000, 0.0000000000, 0.0000000000},
		{0.0433558387, 0.0377445161, 0.0331540645},
		{0.0867107419, 0.0754890323, 0.0663081290},
		{0.1300665161, 0.1132335484, 0.0994621935},
		{0.1735004516, 0.1508860645, 0.1342953548},
		{0.2175938710, 0.1877713548, 0.1846183226},
		{0.2622586452, 0.2239912258, 0.2502985806},
		{0.3069234194, 0.2602108710, 0.2951016774},
		{0.3515884516, 0.2964299677, 0.3399045161},
		{0.3962539677, 0.3326498387, 0.3847068710},
		{0.4409187419, 0.3688693871, 0.4295099677},
		{0.4855835161, 0.4038640323, 0.4743130645},
		{0.5271112581, 0.4349201613, 0.5161331935},
		{0.5592724194, 0.4633072581, 0.5523082258},
		{0.5853859032, 0.4920660323, 0.5872595806},
		{0.6106662581, 0.5221591290, 0.6183104516},
		{0.6348004516, 0.5532223548, 0.6452900645},
		{0.6587339032, 0.5842856129, 0.6722696452},
		{0.6826672581, 0.6153487742, 0.6992487419},
		{0.7066007742, 0.6464120968, 0.7262284516},
		{0.7305340645, 0.6774758387, 0.7532079355},
		{0.7544676452, 0.7078174516, 0.7794168065},
		{0.7783093226, 0.7359619032, 0.8011288065},
		{0.7993624194, 0.7657250000, 0.8198472258},
		{0.8151097742, 0.7903846129, 0.8370887742},
		{0.8294468065, 0.8167878065, 0.8491567742},
		{0.8545193226, 0.8265614839, 0.8674554194},
		{0.8588240000, 0.8274510000, 0.8705880000},
		{0.8588240000, 0.8274510000, 0.8705880000},
		{0.8588240000, 0.8274510000, 0.8705880000},
		{0.8588240000, 0.8274510000, 0.8705880000},
		{0.8588240000, 0.8274510000, 0.8705880000}
	};
	
	constant float plus20m[32][3] = {
		{0.0000000000, 0.0000000000, 0.0000000000},
		{0.0282601290, 0.0285006774, 0.0322580645},
		{0.0565202581, 0.0570022903, 0.0645161290},
		{0.0847804839, 0.0855029355, 0.0967741935},
		{0.1123848710, 0.1138548065, 0.1277798710},
		{0.1345110323, 0.1409655806, 0.1485780323},
		{0.1518808387, 0.1669982903, 0.1624031290},
		{0.1692506452, 0.1930316129, 0.1797267097},
		{0.1866201935, 0.2190641290, 0.1970508387},
		{0.2039892581, 0.2450966452, 0.2143741935},
		{0.2213590645, 0.2711294839, 0.2316978710},
		{0.2387288710, 0.2973290968, 0.2490219032},
		{0.2575773871, 0.3240632903, 0.2673397097},
		{0.2808408387, 0.3511600645, 0.2875392903},
		{0.3069544516, 0.3793890323, 0.3084090968},
		{0.3362131290, 0.4116802903, 0.3348509677},
		{0.3697945484, 0.4469251935, 0.3671090323},
		{0.4041336452, 0.4821701290, 0.3993670968},
		{0.4384727419, 0.5174149677, 0.4316251613},
		{0.4728118387, 0.5526599677, 0.4638832258},
		{0.5071515806, 0.5879047419, 0.4961412903},
		{0.5414910323, 0.6232344839, 0.5292041290},
		{0.5760728387, 0.6598636452, 0.5669636129},
		{0.6180032903, 0.7015154839, 0.6097008387},
		{0.6722043226, 0.7433944516, 0.6563963226},
		{0.7295522258, 0.7819014516, 0.7040154194},
		{0.7739263548, 0.7982211290, 0.7497792903},
		{0.7803920000, 0.8000000000, 0.7568630000},
		{0.7803920000, 0.8000000000, 0.7568630000},
		{0.7803920000, 0.8000000000, 0.7568630000},
		{0.7803920000, 0.8000000000, 0.7568630000},
		{0.7803920000, 0.8000000000, 0.7568630000}
	};
	
	
	constant float minus20y[32][3] = {
		{0.0000000000, 0.0000000000, 0.0000000000},
		{0.0322715161, 0.0313620645, 0.0322580645},
		{0.0645439677, 0.0627241290, 0.0645161290},
		{0.0968154516, 0.0940861935, 0.0967741935},
		{0.1291160968, 0.1255021935, 0.1286052903},
		{0.1616599032, 0.1573683226, 0.1543501935},
		{0.1944144839, 0.1896263871, 0.1644782581},
		{0.2271690645, 0.2218844516, 0.1794129677},
		{0.2599233871, 0.2541425161, 0.1943474194},
		{0.2926772258, 0.2864005806, 0.2092813871},
		{0.3254318065, 0.3186586452, 0.2242157742},
		{0.3581863871, 0.3503117097, 0.2391498065},
		{0.3905968387, 0.3800181613, 0.2571847742},
		{0.4219808387, 0.4084052581, 0.2810875806},
		{0.4527029032, 0.4374959677, 0.3062453226},
		{0.4844101290, 0.4691122903, 0.3351638065},
		{0.5174712903, 0.5025651935, 0.3680087097},
		{0.5507698710, 0.5360181290, 0.4008535806},
		{0.5840684516, 0.5694709677, 0.4336979677},
		{0.6173676452, 0.6029233548, 0.4665423548},
		{0.6506666129, 0.6363763871, 0.4993867419},
		{0.6839651935, 0.6694050645, 0.5335094194},
		{0.7173361613, 0.7021367419, 0.5750890323},
		{0.7526831613, 0.7383817419, 0.6197085484},
		{0.7845595484, 0.7729853548, 0.6642693226},
		{0.8150256129, 0.8053356129, 0.7072059355},
		{0.8428136774, 0.8182738065, 0.7600052258},
		{0.8470590000, 0.8196080000, 0.7686270000},
		{0.8470590000, 0.8196080000, 0.7686270000},
		{0.8470590000, 0.8196080000, 0.7686270000},
		{0.8470590000, 0.8196080000, 0.7686270000},
		{0.8470590000, 0.8196080000, 0.7686270000}
	};
	
	constant float plus20y[32][3] = {
		{0.0000000000, 0.0000000000, 0.0000000000},
		{0.0311968710, 0.0321796129, 0.0331540645},
		{0.0623928065, 0.0643592258, 0.0663081290},
		{0.0935897097, 0.0965387419, 0.0994621935},
		{0.1244915161, 0.1285516452, 0.1321100645},
		{0.1529316774, 0.1591822258, 0.1636379677},
		{0.1792338065, 0.1886106774, 0.2073914516},
		{0.2055367742, 0.2180385161, 0.2474151935},
		{0.2318397419, 0.2474671613, 0.2874389355},
		{0.2581424194, 0.2768958065, 0.3274626774},
		{0.2844446774, 0.3063241290, 0.3674864194},
		{0.3107476452, 0.3357911290, 0.4075101613},
		{0.3375379677, 0.3653840323, 0.4483092581},
		{0.3657838387, 0.3950614516, 0.4905754839},
		{0.3949699032, 0.4253462903, 0.5327296774},
		{0.4263251613, 0.4578114516, 0.5688941290},
		{0.4606616774, 0.4918620323, 0.5988063871},
		{0.4955210323, 0.5259120968, 0.6287186129},
		{0.5303809677, 0.5599621613, 0.6586303548},
		{0.5652407419, 0.5940122258, 0.6885420968},
		{0.6001000968, 0.6280622903, 0.7184544839},
		{0.6349594516, 0.6591845484, 0.7472793226},
		{0.6697556452, 0.6871409355, 0.7697560968},
		{0.7029620968, 0.7251542581, 0.7914189677},
		{0.7433693226, 0.7583041935, 0.8154455484},
		{0.7863796129, 0.7919204194, 0.8335832903},
		{0.8188378710, 0.8030324839, 0.8519574839},
		{0.8235290000, 0.8039220000, 0.8549020000},
		{0.8235290000, 0.8039220000, 0.8549020000},
		{0.8235290000, 0.8039220000, 0.8549020000},
		{0.8235290000, 0.8039220000, 0.8549020000},
		{0.8235290000, 0.8039220000, 0.8549020000}
	};
	
	constant float negToLinear[32][3] = {
		{ 2.072899,  1.920966,  2.571896},
		{ 1.923858,  1.716715,  2.078431},
		{ 1.774817,  1.512464,  1.584967},
		{ 1.625776,  1.308213,  1.091503},
		{ 1.476734,  1.103961,  0.638263},
		{ 1.327693,  0.787271,  0.474641},
		{ 1.178652,  0.559990,  0.313196},
		{ 1.029611,  0.477338,  0.265946},
		{ 0.780543,  0.337054,  0.217084},
		{ 0.680554,  0.292311,  0.144555},
		{ 0.536688,  0.253697,  0.064582},
		{ 0.482522,  0.211844, -0.021716},
		{ 0.396266,  0.154038, -0.108009},
		{ 0.320013,  0.094980, -0.194302},
		{ 0.294766,  0.030096, -0.280594},
		{ 0.271654, -0.034826, -0.366887},
		{ 0.247848, -0.099779, -0.453221},
		{ 0.223512, -0.164701, -0.539513},
		{ 0.177183, -0.229623, -0.625806},
		{ 0.128223, -0.294546, -0.712099},
		{ 0.072874, -0.359468, -0.798392},
		{ 0.014145, -0.424390, -0.884684},
		{-0.044489, -0.489313, -0.970977},
		{-0.103123, -0.554235, -1.057270},
		{-0.161757, -0.619157, -1.143563},
		{-0.220392, -0.684080, -1.229856},
		{-0.279026, -0.749002, -1.316148},
		{-0.337660, -0.813924, -1.402441},
		{-0.396294, -0.878847, -1.488734},
		{-0.454929, -0.943769, -1.575027},
		{-0.513563, -1.008691, -1.661319},
		{-0.572197, -1.073613, -1.747612}
	};
	
	
	constant float linearToPrintCurve[32][3] = {
		{0.1253376059, 0.1349202716, 0.1472190433},
		{0.1269312057, 0.1351501278, 0.1497198227},
		{0.1308217702, 0.1374428957, 0.1541420934},
		{0.1395165497, 0.1440503451, 0.1625832578},
		{0.1530155442, 0.1549724760, 0.1750433159},
		{0.1715999880, 0.1705288343, 0.1917988840},
		{0.1964987584, 0.1922081475, 0.2141157461},
		{0.2255885482, 0.2181486700, 0.2402455952},
		{0.2570932163, 0.2467556184, 0.2687008178},
		{0.2927688502, 0.2796081551, 0.3009407163},
		{0.3340132654, 0.3178299748, 0.3380410470},
		{0.3794554449, 0.3598632913, 0.3786533060},
		{0.4278447524, 0.4046392076, 0.4218528810},
		{0.4763931267, 0.4498408459, 0.4656076601},
		{0.5226183993, 0.4932801119, 0.5079208103},
		{0.5649030861, 0.5334911011, 0.5474588027},
		{0.6029235958, 0.5701266768, 0.5840050018},
		{0.6379723502, 0.6041730135, 0.6184795579},
		{0.6719803224, 0.6372037505, 0.6522434956},
		{0.7036363777, 0.6680392855, 0.6840762859},
		{0.7308773865, 0.6948804918, 0.7121462737},
		{0.7534991500, 0.7176204709, 0.7361947579},
		{0.7716440970, 0.7364263751, 0.7562793793},
		{0.7849467696, 0.7510334384, 0.7718212125},
		{0.7954078234, 0.7632259862, 0.7844729548},
		{0.8049538258, 0.7746997836, 0.7959279151},
		{0.8134765237, 0.7853665349, 0.8059700799},
		{0.8205131664, 0.7948187341, 0.8140954558},
		{0.8264086497, 0.8032941241, 0.8208888383},
		{0.8312379392, 0.8108470158, 0.8264689812},
		{0.8350010349, 0.8174774093, 0.8308358847},
		{0.8382543679, 0.8236667430, 0.8346227207}
	};
	
	
	// MARK: - Print Curve
	
	// Updated Print Curve - Taken from 10x8 LVT Neg
	// Input should be gamma 2.2
	float4 printCurve(coreimage::sample_t s, coreimage::sample_t f, int applyFlash) {

		// Define RGB as a float3 using the sample's RGB values
		float3 RGB = float3(s.r, s.g, s.b);
		float3 flash = float3(f.r, f.g, f.b);

		// Map the RGB channels using the provided input and output mappings
//		RGB = mapRGB32(RGB, outputMap);
		
		// now using printCurveJune25
		RGB = mapRGB32(RGB, printCurveJune25);
		
		if (applyFlash == 1) {
			RGB *= flash;
		}

		// Return the result with the original alpha channel
		return float4(RGB, s.a);
	}
	
	
	
	float4 ilfordCurve(coreimage::sample_t s, coreimage::sample_t f, int applyFlash) {

		// Define RGB as a float3 using the sample's RGB values
		float3 rgb = float3(s.r, s.g, s.b);
		
		// now using printCurveJune25
		rgb = mapRGB32(rgb, ilfordRC_v1);
		
		float gray = (rgb.x + rgb.y + rgb.z) / 3.0;
		rgb = float3(gray, gray, gray);
		
		// Return the result with the original alpha channel
		return float4(rgb, s.a);
	}
	
	
	
	// Map white point and blackpoint to 0 and 1
	float4 mapOutputValues(coreimage::sample_t s) {
		float3 rgb = float3(s.r, s.g, s.b);
		// Lowest / highest values from print lut
		float blackPoint = 0.0232843137;
		float whitePoint = 0.9346130168;
		
		rgb = clamp((rgb - blackPoint) / (whitePoint - blackPoint), 0.0, 1.0);
		
		return float4(rgb, s.a);
	}

	
	
	/*
	 Tone mapping values in neg space:
	 
	 0.4351 midtone grey in cineon - now convert this to negative
	 
	 
	 
	 
	 
	 */
	
	float3 decodeNegativeF3(float3 rgb) {

		// Kodak Portra
		float dMinRed = 0.466;
		float redDensity = 2.1466;
		float dMinGreen = 0.206;
		float greenDensity = 2.7104;
		float dMinBlue = 0.109;
		float blueDensity = 3.1870;

		// Decode each channel
		rgb.r = dMinRed / pow(10, ((rgb.r * 1023.0 - 95.0) / (1023.0 / redDensity)));
		rgb.g = dMinGreen / pow(10, ((rgb.g * 1023.0 - 95.0) / (1023.0 / greenDensity)));
		rgb.b = dMinBlue / pow(10, ((rgb.b * 1023.0 - 95.0) / (1023.0 / blueDensity)));

		return rgb;
	}
	
	float decodeDMax(float encoded) {
		// Constants used in the encoding formula
		const float scale = 1023.0 / 2.048;
		const float offset = 95.0;
		const float multiplier = 0.002;

		// Inverse of: encoded = (log10(1.0 / dMaxBlue) * scale + offset) * multiplier
		float exponent = (encoded / multiplier - offset) / scale;
		float dMax = 1.0 / pow(10.0, exponent);

		return dMax;
	}
	
	inline float tone_map_single(float input, float black_point, float white_point, float midtone) {
		float c = black_point;
		float a = white_point - c;
		float b = (a / (midtone - c)) * (1.0 - (midtone - c) / a) * midtone;
		
		return a * (input / (input + b)) + c;
	}
	
	inline float3 toneMapNeg(float3 rgb) {
		float r = rgb.x;
		float g = rgb.y;
		float b = rgb.z;
		
		float3 midTone = float3(0.4351, 0.4351, 0.4351);
		float3 mtn = decodeNegativeF3(midTone);
		
		float rMid = mtn.x;
		float gMid = mtn.y;
		float bMid = mtn.z;
		
		float rMin = 0.466;
		float gMin = 0.206;
		float bMin = 0.109;
		
		float rMax = decodeDMax(2.1466);
		float gMax = decodeDMax(2.7104);
		float bMax = decodeDMax(3.1870);
		
		r = tone_map_single(r, rMax, rMin, rMid);
		g = tone_map_single(g, gMax, gMin, gMid);
		b = tone_map_single(b, bMax, bMin, bMid);
		
		r = clamp(r, rMax, rMin);
		g = clamp(g, gMax, gMin);
		b = clamp(b, bMax, bMin);
		
		
		return float3(r, g, b);
	}
	
	
	// Enlarger Filtration kernel
	// Input: Linear
	// Output: Gamma 2.2
	// All values normalised by: Value
	float4 enlargerFiltrationKernel(coreimage::sample_t s,
							float cyanValue,
							float magentaValue,
							float yellowValue,
							float exposureValue)
	{
		// --- Step 1: Decode from Gamma 2.2 ---
		float3 rgb = pow(float3(s.r, s.g, s.b), 2.2);


		int redoCyan = 0;
		int redoMagenta = 0;
		int redoYellow = 0;
		
		float cyan2 = cyanValue - 1.0;
		float magenta2 = magentaValue - 1.0;
		float yellow2 = yellowValue - 1.0;
		
		
		if (cyanValue > 0.0) {
			redoCyan = 1;
		}
		if (magentaValue > 0.0) {
			redoMagenta = 1;
		}
		if (yellowValue > 0.0) {
			redoYellow = 1;
		}
		
		
		rgb *= pow(2, exposureValue);
		
		cyanValue = clamp(cyanValue, -1000.0, 0.0);
		magentaValue = clamp(magentaValue, -1000.0, 0.0);
		yellowValue = clamp(yellowValue, -1000.0, 0.0);
		
		// Reversed
		rgb.z *= -yellowValue;
		rgb.y *= -magentaValue;
		rgb.x *= -cyanValue;
		
		
		if (redoYellow == 1) {
			yellow2 = clamp(yellow2, -1000.0, 0.0);
			rgb.z *= -yellow2;
		}
		if (redoMagenta == 1) {
			magenta2 = clamp(magenta2, -1000.0, 0.0);
			rgb.y *= -magenta2;
		}
		if (redoCyan == 1) {
			cyan2 = clamp(cyan2, -1000.0, 0.0);
			rgb.x *= -cyan2;
		}


		// --- Step 6: Encode back to Gamma 2.2 ---
		float3 finalGammaRGB;
		for (int i = 0; i < 3; i++) {
			finalGammaRGB[i] = pow(rgb[i], 1.0 / 2.2); // Gamma encoding
		}


		 // Return the clamped and adjusted color, preserving alpha
		 return float4(finalGammaRGB, s.a);
	}
	
	float3 applySteps(float3 rgb, float steps, constant float lut[32][3]) {
		if (steps == 0.0) return rgb;

		float absSteps = fabs(steps);
		int floorSteps = int(floor(absSteps));
		float mixVal = absSteps - float(floorSteps);

		float3 temp = rgb;
		for (int i = 0; i < floorSteps; ++i) {
			temp = mapRGB32(temp, lut);
		}

		float3 tempNext = mapRGB32(temp, lut);
		return mix(temp, tempNext, mixVal);
	}
	
	float4 enlargerCurves(coreimage::sample_t s,
						  float exposureSteps,
						  float yellowSteps,
						  float magentaSteps,
						  float cyanSteps)
	{
		float3 rgb = float3(s.r, s.g, s.b);
		
		rgb = mapRGB32(rgb, outputMap);
		
		if (exposureSteps > 0.0)
			rgb = applySteps(rgb, exposureSteps, plus1ev);
		else
			rgb = applySteps(rgb, exposureSteps, minus1ev);
		
		if (yellowSteps > 0.0) {
			rgb = applySteps(rgb, yellowSteps, plus20y);
		} else {
			rgb = applySteps(rgb, yellowSteps, minus20y);
		}
		
		if (magentaSteps > 0.0) {
			rgb = applySteps(rgb, magentaSteps, plus20m);
		} else {
			rgb = applySteps(rgb, magentaSteps, minus20m);
		}
		
		if (cyanSteps > 0.0) {
			rgb = applySteps(rgb, cyanSteps, plus1ev);
			rgb = applySteps(rgb, cyanSteps, plus20m);
		} else {
			rgb = applySteps(rgb, cyanSteps, minus1ev);
			rgb = applySteps(rgb, cyanSteps, minus20m);
		}
		
//		rgb = mapRGB32(rgb, linearToPrintCurve);
		
		return float4(rgb, s.a);
	}
	
	float4 enlargerOffsets(coreimage::sample_t s,
						   float cyanValue,
						   float magentaValue,
						   float yellowValue,
						   float exposureSteps,
						   int exposureMode) {
		float3 rgb = float3(s.r, s.g, s.b);
		
		
		rgb += exposureSteps;
		
//		if (exposureMode == 1) {
//			rgb = pow(rgb, 2.2);
//			rgb *= pow(2, exposureSteps);
//			rgb = pow(rgb, 1.0 / 2.2);
//			return float4(rgb, s.a);
//		} else {
			rgb.z += yellowValue;
			rgb.y += magentaValue;
			rgb.x += cyanValue;
			
			return float4(rgb, s.a);
//		}
	}
	
	
	float4 enlargerV2(coreimage::sample_t s, float ev, float c, float m, float y) {
		float3 rgb = float3(s.r, s.g, s.b);
    
		
		rgb = pow(rgb, 2.2f);
		
		rgb *= pow(2.0f, ev);
		rgb.x *= c;
		rgb.y *= m;
		rgb.z *= y;
		
		rgb = pow(rgb, (1.0f / 2.2f));
		
		return float4(rgb, s.a);
	}
    
    
    float4 enlargerV2Masked(coreimage::sample_t s,
                            float evMask, float cMask, float mMask, float yMask) {
        float3 rgb = float3(s.r, s.g, s.b);
        
        cMask = clamp(cMask, 0.0, 100.0);
        mMask = clamp(mMask, 0.0, 100.0);
        yMask = clamp(yMask, 0.0, 100.0);
        

        rgb = pow(rgb, 2.2f);
        
        rgb *= pow(2.0f, evMask);
        rgb.x *= cMask;
        rgb.y *= mMask;
        rgb.z *= yMask;
        
        rgb = pow(rgb, (1.0f / 2.2f));
        
        return float4(rgb, s.a);
    }
	
	float4 enlargerBW(coreimage::sample_t s, float ev, float c) {
		float3 rgb = float3(s.r, s.g, s.b);
		float gray = (rgb.r + rgb.g + rgb.b) / 3.0;
		float pivot = 0.305;
		
		gray = pow(gray, 2.2f);
		gray *= pow(2.0f, ev);
		gray = pow(gray, (1.0f / 2.2f));
		
		c = 1.0 - (1.0 - c);
		
		gray = (gray - pivot) * c + pivot;
		
		float3 grayF3 = float3(gray, gray, gray);
		
		grayF3 = mapRGB32(grayF3, ilfordRC_v3);
		
		return float4(grayF3, s.a);
	}
	
	
	// MARK: - Legacy
	
	
	
	float4 legacyEnlarger(coreimage::sample_t s,
							float cyanValue,
							float magentaValue,
							float yellowValue,
							float exposureValue)
	{
		// --- Step 1: Decode from Gamma 2.2 ---
		float3 gammaRGB = float3(s.r, s.g, s.b);
		float3 linearRGB;
		for (int i = 0; i < 3; i++) {
			linearRGB[i] = pow(gammaRGB[i], 2.2); // Gamma decoding
		}

		// --- Step 2: Apply Cyan Adjustment ---
		float cyanMapped = cyanValue < 0 ? mix(1.0, 1.25, -cyanValue / 100.0) : mix(1.0, 0.75, cyanValue / 100.0);
		linearRGB.r *= cyanMapped;

		// --- Step 3: Apply Magenta Adjustment ---
		float magentaMapped = magentaValue < 0 ? mix(1.0, 1.25, -magentaValue / 100.0) : mix(1.0, 0.75, magentaValue / 100.0);
		linearRGB.g *= magentaMapped;

		// --- Step 4: Apply Yellow Adjustment ---
		float yellowMapped = yellowValue < 0 ? mix(1.0, 1.5, -yellowValue / 100.0) : mix(1.0, 0.5, yellowValue / 100.0);
		linearRGB.b *= yellowMapped;

		// --- Step 5: Apply Exposure Adjustment ---
		float exposureMapped = exposureValue < 0 ? mix(1.0, 3.0, -exposureValue / 100.0) : mix(1.0, 0.0, exposureValue / 100.0);
		linearRGB *= exposureMapped;

		// --- Step 6: Encode back to Gamma 2.2 ---
		float3 finalGammaRGB;
		for (int i = 0; i < 3; i++) {
			finalGammaRGB[i] = pow(linearRGB[i], 1.0 / 2.2); // Gamma encoding
		}
		
		// --- Step 7: Clamp the final gamma-encoded output ---
		 finalGammaRGB.r = clamp(finalGammaRGB.r, 0.025883, 0.97); // Clamp Red
		 finalGammaRGB.g = clamp(finalGammaRGB.g, 0.024528, 0.97); // Clamp Green
		 finalGammaRGB.b = clamp(finalGammaRGB.b, 0.021521, 0.97); // Clamp Blue

		 // Return the clamped and adjusted color, preserving alpha
		 return float4(finalGammaRGB, s.a);
	}
	
	
	constant float legacyGrade0[32][3] = {
		{0.937255, 0.937255, 0.937255},
		{0.928311, 0.928311, 0.928311},
		{0.916003, 0.916003, 0.916003},
		{0.879163, 0.879163, 0.879163},
		{0.812490, 0.812490, 0.812490},
		{0.736482, 0.736482, 0.736482},
		{0.668425, 0.668425, 0.668425},
		{0.605587, 0.605587, 0.605587},
		{0.547605, 0.547605, 0.547605},
		{0.498932, 0.498932, 0.498932},
		{0.459409, 0.459409, 0.459409},
		{0.426350, 0.426350, 0.426350},
		{0.397213, 0.397213, 0.397213},
		{0.370183, 0.370183, 0.370183},
		{0.344401, 0.344401, 0.344401},
		{0.318901, 0.318901, 0.318901},
		{0.292923, 0.292923, 0.292923},
		{0.266472, 0.266472, 0.266472},
		{0.239946, 0.239946, 0.239946},
		{0.213760, 0.213760, 0.213760},
		{0.188274, 0.188274, 0.188274},
		{0.163831, 0.163831, 0.163831},
		{0.140649, 0.140649, 0.140649},
		{0.119609, 0.119609, 0.119609},
		{0.105665, 0.105665, 0.105665},
		{0.097322, 0.097322, 0.097322},
		{0.092186, 0.092186, 0.092186},
		{0.089270, 0.089270, 0.089270},
		{0.087763, 0.087763, 0.087763},
		{0.087022, 0.087022, 0.087022},
		{0.086606, 0.086606, 0.086606},
		{0.086275, 0.086275, 0.086275}
	};
	
	
	float4 legacyGrade0Curve(coreimage::sample_t s, float magentaValue) {


		// Define RGB as a float3 using the sample's RGB values
		float3 RGB = float3(s.r, s.g, s.b);

		// Map the RGB channels using the provided input and output mappings
		RGB = mapRGB32(RGB, legacyGrade0);

		// Desaturate the image by converting to grayscale (average of RGB channels)
		float grayscale = (RGB.r + RGB.g + RGB.b) / 3.0;

		// Set RGB to the desaturated value
		RGB = float3(grayscale, grayscale, grayscale);
		
		float contrast = pow(1.04, magentaValue / 10.0);  // Adjust contrast
		float3 contrastAdjustedRGB = (RGB - 0.5) * contrast + 0.5;
		
		contrastAdjustedRGB = clamp(contrastAdjustedRGB, 0.0, 1.0);

		// Return the result with the original alpha channel
		return float4(contrastAdjustedRGB, s.a);
	}
	
	// No Split Tone
	constant float legacyCurve[32][3] = {
		{0.9137254902, 0.9137254902, 0.9137160433},
		{0.9137254902, 0.9137251008, 0.9132164287},
		{0.9137254902, 0.9136863092, 0.9065719407},
		{0.9137254902, 0.9127539646, 0.8690264908},
		{0.9137248995, 0.9037319907, 0.7612881037},
		{0.9136952338, 0.8633435192, 0.5822429465},
		{0.9131453779, 0.7671307204, 0.3835657605},
		{0.9085740807, 0.6215398499, 0.2221173575},
		{0.8890990171, 0.4559826974, 0.1267670173},
		{0.8402518349, 0.3020768924, 0.0835366824},
		{0.7569793280, 0.1854755668, 0.0684758157},
		{0.6440434789, 0.1139494993, 0.0640181297},
		{0.5138248164, 0.0799506500, 0.0629191631},
		{0.3953151219, 0.0676461981, 0.0627563642},
		{0.2981979460, 0.0638404663, 0.0627453858},
		{0.2110902388, 0.0628931690, 0.0627450980},
		{0.1411527197, 0.0627545404, 0.0627450980},
		{0.1002665023, 0.0627453351, 0.0627450980},
		{0.0810581272, 0.0627450980, 0.0627450980},
		{0.0718593436, 0.0627450980, 0.0627450980},
		{0.0671789120, 0.0627450980, 0.0627450980},
		{0.0646138308, 0.0627450980, 0.0627450980},
		{0.0632616679, 0.0627450980, 0.0627450980},
		{0.0628179136, 0.0627450980, 0.0627450980},
		{0.0627495474, 0.0627450980, 0.0627450980},
		{0.0627451996, 0.0627450980, 0.0627450980},
		{0.0627450980, 0.0627450980, 0.0627450980},
		{0.0627450980, 0.0627450980, 0.0627450980},
		{0.0627450980, 0.0627450980, 0.0627450980},
		{0.0627450980, 0.0627450980, 0.0627450980},
		{0.0627450980, 0.0627450980, 0.0627450980},
		{0.0627450980, 0.0627450980, 0.0627450980}
	};

	
	
	// Updated Print Curve - Taken from 10x8 LVT Neg
	float4 legacyPrintCurve(coreimage::sample_t s) {


		// Define RGB as a float3 using the sample's RGB values
		float3 RGB = float3(s.r, s.g, s.b);

		// Map the RGB channels using the provided input and output mappings
		RGB = mapRGB32(RGB, legacyCurve);


		// Return the result with the original alpha channel
		return float4(RGB, s.a);
	}
	
	
	
}


